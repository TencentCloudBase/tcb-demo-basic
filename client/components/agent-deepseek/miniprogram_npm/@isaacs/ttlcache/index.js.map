{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["// A simple TTL cache with max capacity option, ms resolution,\n// autopurge, and reasonably optimized performance\n// Relies on the fact that integer Object keys are kept sorted,\n// and managed very efficiently by V8.\n\n/* istanbul ignore next */\nconst perf =\n  typeof performance === 'object' &&\n  performance &&\n  typeof performance.now === 'function'\n    ? performance\n    : Date\n\nconst now = () => perf.now()\nconst isPosInt = n => n && n === Math.floor(n) && n > 0 && isFinite(n)\nconst isPosIntOrInf = n => n === Infinity || isPosInt(n)\n\nclass TTLCache {\n  constructor({\n    max = Infinity,\n    ttl,\n    updateAgeOnGet = false,\n    checkAgeOnGet = false,\n    noUpdateTTL = false,\n    dispose,\n    noDisposeOnSet = false,\n  } = {}) {\n    // {[expirationTime]: [keys]}\n    this.expirations = Object.create(null)\n    // {key=>val}\n    this.data = new Map()\n    // {key=>expiration}\n    this.expirationMap = new Map()\n    if (ttl !== undefined && !isPosIntOrInf(ttl)) {\n      throw new TypeError(\n        'ttl must be positive integer or Infinity if set'\n      )\n    }\n    if (!isPosIntOrInf(max)) {\n      throw new TypeError('max must be positive integer or Infinity')\n    }\n    this.ttl = ttl\n    this.max = max\n    this.updateAgeOnGet = !!updateAgeOnGet\n    this.checkAgeOnGet = !!checkAgeOnGet\n    this.noUpdateTTL = !!noUpdateTTL\n    this.noDisposeOnSet = !!noDisposeOnSet\n    if (dispose !== undefined) {\n      if (typeof dispose !== 'function') {\n        throw new TypeError('dispose must be function if set')\n      }\n      this.dispose = dispose\n    }\n\n    this.timer = undefined\n    this.timerExpiration = undefined\n  }\n\n  setTimer(expiration, ttl) {\n    if (this.timerExpiration < expiration) {\n      return\n    }\n\n    if (this.timer) {\n      clearTimeout(this.timer)\n    }\n\n    const t = setTimeout(() => {\n      this.timer = undefined\n      this.timerExpiration = undefined\n      this.purgeStale()\n      for (const exp in this.expirations) {\n        this.setTimer(exp, exp - now())\n        break\n      }\n    }, ttl)\n\n    /* istanbul ignore else - affordance for non-node envs */\n    if (t.unref) t.unref()\n\n    this.timerExpiration = expiration\n    this.timer = t\n  }\n\n  // hang onto the timer so we can clearTimeout if all items\n  // are deleted.  Deno doesn't have Timer.unref(), so it\n  // hangs otherwise.\n  cancelTimer() {\n    if (this.timer) {\n      clearTimeout(this.timer)\n      this.timerExpiration = undefined\n      this.timer = undefined\n    }\n  }\n\n  /* istanbul ignore next */\n  cancelTimers() {\n    process.emitWarning(\n      'TTLCache.cancelTimers has been renamed to ' +\n        'TTLCache.cancelTimer (no \"s\"), and will be removed in the next ' +\n        'major version update'\n    )\n    return this.cancelTimer()\n  }\n\n  clear() {\n    const entries =\n      this.dispose !== TTLCache.prototype.dispose ? [...this] : []\n    this.data.clear()\n    this.expirationMap.clear()\n    // no need for any purging now\n    this.cancelTimer()\n    this.expirations = Object.create(null)\n    for (const [key, val] of entries) {\n      this.dispose(val, key, 'delete')\n    }\n  }\n\n  setTTL(key, ttl = this.ttl) {\n    const current = this.expirationMap.get(key)\n    if (current !== undefined) {\n      // remove from the expirations list, so it isn't purged\n      const exp = this.expirations[current]\n      if (!exp || exp.length <= 1) {\n        delete this.expirations[current]\n      } else {\n        this.expirations[current] = exp.filter(k => k !== key)\n      }\n    }\n\n    if (ttl !== Infinity) {\n      const expiration = Math.floor(now() + ttl)\n      this.expirationMap.set(key, expiration)\n      if (!this.expirations[expiration]) {\n        this.expirations[expiration] = []\n        this.setTimer(expiration, ttl)\n      }\n      this.expirations[expiration].push(key)\n    } else {\n      this.expirationMap.set(key, Infinity)\n    }\n  }\n\n  set(\n    key,\n    val,\n    {\n      ttl = this.ttl,\n      noUpdateTTL = this.noUpdateTTL,\n      noDisposeOnSet = this.noDisposeOnSet,\n    } = {}\n  ) {\n    if (!isPosIntOrInf(ttl)) {\n      throw new TypeError('ttl must be positive integer or Infinity')\n    }\n    if (this.expirationMap.has(key)) {\n      if (!noUpdateTTL) {\n        this.setTTL(key, ttl)\n      }\n      // has old value\n      const oldValue = this.data.get(key)\n      if (oldValue !== val) {\n        this.data.set(key, val)\n        if (!noDisposeOnSet) {\n          this.dispose(oldValue, key, 'set')\n        }\n      }\n    } else {\n      this.setTTL(key, ttl)\n      this.data.set(key, val)\n    }\n\n    while (this.size > this.max) {\n      this.purgeToCapacity()\n    }\n\n    return this\n  }\n\n  has(key) {\n    return this.data.has(key)\n  }\n\n  getRemainingTTL(key) {\n    const expiration = this.expirationMap.get(key)\n    return expiration === Infinity\n      ? expiration\n      : expiration !== undefined\n      ? Math.max(0, Math.ceil(expiration - now()))\n      : 0\n  }\n\n  get(\n    key,\n    {\n      updateAgeOnGet = this.updateAgeOnGet,\n      ttl = this.ttl,\n      checkAgeOnGet = this.checkAgeOnGet,\n    } = {}\n  ) {\n    const val = this.data.get(key)\n    if (checkAgeOnGet && this.getRemainingTTL(key) === 0) {\n      this.delete(key)\n      return undefined\n    }\n    if (updateAgeOnGet) {\n      this.setTTL(key, ttl)\n    }\n    return val\n  }\n\n  dispose(_, __) {}\n\n  delete(key) {\n    const current = this.expirationMap.get(key)\n    if (current !== undefined) {\n      const value = this.data.get(key)\n      this.data.delete(key)\n      this.expirationMap.delete(key)\n      const exp = this.expirations[current]\n      if (exp) {\n        if (exp.length <= 1) {\n          delete this.expirations[current]\n        } else {\n          this.expirations[current] = exp.filter(k => k !== key)\n        }\n      }\n      this.dispose(value, key, 'delete')\n      if (this.size === 0) {\n        this.cancelTimer()\n      }\n      return true\n    }\n    return false\n  }\n\n  purgeToCapacity() {\n    for (const exp in this.expirations) {\n      const keys = this.expirations[exp]\n      if (this.size - keys.length >= this.max) {\n        delete this.expirations[exp]\n        const entries = []\n        for (const key of keys) {\n          entries.push([key, this.data.get(key)])\n          this.data.delete(key)\n          this.expirationMap.delete(key)\n        }\n        for (const [key, val] of entries) {\n          this.dispose(val, key, 'evict')\n        }\n      } else {\n        const s = this.size - this.max\n        const entries = []\n        for (const key of keys.splice(0, s)) {\n          entries.push([key, this.data.get(key)])\n          this.data.delete(key)\n          this.expirationMap.delete(key)\n        }\n        for (const [key, val] of entries) {\n          this.dispose(val, key, 'evict')\n        }\n        return\n      }\n    }\n  }\n\n  get size() {\n    return this.data.size\n  }\n\n  purgeStale() {\n    const n = Math.ceil(now())\n    for (const exp in this.expirations) {\n      if (exp === 'Infinity' || exp > n) {\n        return\n      }\n\n      /* istanbul ignore next\n       * mysterious need for a guard here?\n       * https://github.com/isaacs/ttlcache/issues/26 */\n      const keys = [...(this.expirations[exp] || [])]\n      const entries = []\n      delete this.expirations[exp]\n      for (const key of keys) {\n        entries.push([key, this.data.get(key)])\n        this.data.delete(key)\n        this.expirationMap.delete(key)\n      }\n      for (const [key, val] of entries) {\n        this.dispose(val, key, 'stale')\n      }\n    }\n    if (this.size === 0) {\n      this.cancelTimer()\n    }\n  }\n\n  *entries() {\n    for (const exp in this.expirations) {\n      for (const key of this.expirations[exp]) {\n        yield [key, this.data.get(key)]\n      }\n    }\n  }\n  *keys() {\n    for (const exp in this.expirations) {\n      for (const key of this.expirations[exp]) {\n        yield key\n      }\n    }\n  }\n  *values() {\n    for (const exp in this.expirations) {\n      for (const key of this.expirations[exp]) {\n        yield this.data.get(key)\n      }\n    }\n  }\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n}\n\nmodule.exports = TTLCache\n"]}