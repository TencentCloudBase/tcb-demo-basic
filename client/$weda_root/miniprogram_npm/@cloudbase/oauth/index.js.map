{"version":3,"sources":["index.js","auth/index.js","auth/consts.js","oauthclient/index.js","app/internal.js","oauthclient/oauthclient.js","oauthclient/consts.js","utils/uuid.js","utils/base64.js","utils/promise.js","captcha/index.js","utils/mp.js","app/index.js","app/request.js","app/openuri.js","app/storage.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA,AGTA;ADIA,ADGA,ADGA,AGTA;ADIA,ADGA,ADGA,AGTA;ACFA,AFMA,ADGA,ADGA,AGTA;ACFA,AFMA,ADGA,ADGA,AGTA;ACFA,AFMA,ADGA,ADGA,AGTA;ACFA,AFMA,ADGA,ADGA,AGTA,AENA;ADIA,AFMA,ADGA,ADGA,AGTA,AENA;ADIA,AFMA,ADGA,ADGA,AGTA,AENA;ADIA,AFMA,ADGA,ADGA,AMlBA,AHSA,AENA;ADIA,AFMA,ADGA,ADGA,AMlBA,AHSA,AENA;ADIA,AFMA,ADGA,ADGA,AMlBA,AHSA,AENA;ADIA,AFMA,ADGA,ADGA,AMlBA,AHSA,AENA,AENA;AHUA,AFMA,ADGA,ADGA,AMlBA,AHSA,AENA,AENA;AHUA,AFMA,ADGA,ADGA,AMlBA,AHSA,AENA,AENA;AHUA,AFMA,ADGA,AKfA,AHSA,AENA,AGTA,ADGA;AHUA,AFMA,ADGA,AKfA,AHSA,AENA,AGTA,ADGA;AHUA,AFMA,ADGA,AKfA,AHSA,AENA,AGTA,ADGA;AHUA,AFMA,ADGA,AKfA,AHSA,AENA,AGTA,ACHA,AFMA;AHUA,AFMA,ADGA,AKfA,AHSA,AENA,AGTA,ACHA,AFMA;AHUA,AFMA,ADGA,AKfA,AHSA,AENA,AGTA,ACHA,AFMA;AHUA,AFMA,ADGA,AS3BA,AJYA,ADGA,AGTA,ACHA,AFMA;AHUA,AFMA,ADGA,AS3BA,AJYA,ADGA,AGTA,ACHA,AFMA;AHUA,AFMA,ADGA,AS3BA,AJYA,ADGA,AGTA,ACHA,AFMA;AHUA,AFMA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA,AFMA;AHUA,AFMA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA,AFMA;AHUA,AFMA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA,AFMA;AKdA,ARwBA,AFMA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA,AFMA;AKdA,AV8BA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA;AGRA,AV8BA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA;AGRA,ACHA,AXiCA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA;AGRA,ACHA,AXiCA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA;AGRA,ACHA,AXiCA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA;AGRA,AENA,ADGA,AXiCA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA;AGRA,AENA,ADGA,AXiCA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA;AGRA,AENA,ADGA,AXiCA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA;AGRA,AENA,ADGA,AENA,AbuCA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA;AGRA,AENA,ADGA,AENA,AbuCA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA;AGRA,AENA,ADGA,AENA,AbuCA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA;AGRA,AENA,ADGA,AENA,AbuCA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA;AGRA,AENA,ADGA,AENA,AbuCA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA;AGRA,AENA,ADGA,AENA,AbuCA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA;AGRA,AENA,ADGA,AENA,AbuCA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA;AGRA,AENA,ADGA,AENA,AbuCA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA;AGRA,AENA,ADGA,AENA,AbuCA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA;AGRA,AENA,ADGA,AENA,AbuCA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA;AGRA,AENA,ADGA,AENA,AbuCA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA;AGRA,AENA,ADGA,AENA,AbuCA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA;AGRA,AENA,ADGA,AENA,AbuCA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA;AGRA,AENA,ADGA,AENA,AbuCA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA;AGRA,AENA,ADGA,AENA,AbuCA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA;AGRA,AENA,ADGA,AENA,AbuCA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA;AGRA,AENA,ADGA,AENA,AbuCA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA;AGRA,AENA,ADGA,AENA,AbuCA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA;AGRA,AENA,ADGA,AENA,AbuCA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA;AGRA,AENA,ADGA,AENA,AbuCA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA;AGRA,AENA,ADGA,AENA,AbuCA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA;AGRA,AENA,ADGA,AENA,AbuCA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA;AGRA,AENA,ADGA,AENA,AbuCA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA;AGRA,AENA,ADGA,AENA,AbuCA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA;AGRA,AENA,ADGA,AENA,AbuCA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA;AGRA,AENA,ADGA,AENA,AbuCA,ADGA,AS3BA,AJYA,ADGA,AGTA,AGTA,AFMA;AGRA,AENA,ADGA,AENA,AbuCA,ADGA,AS3BA,ALeA,AGTA,AGTA,AFMA;AGRA,AENA,ADGA,AENA,AbuCA,ADGA,AS3BA,ALeA,AGTA,AGTA,AFMA;AGRA,AENA,ADGA,AENA,AbuCA,ADGA,AS3BA,ALeA,AGTA,AGTA,AFMA;AGRA,AENA,ADGA,AENA,AbuCA,ADGA,AS3BA,ALeA,AGTA,AGTA,AFMA;AGRA,AENA,ADGA,AENA,AbuCA,ADGA,AS3BA,ALeA,AGTA,AGTA;ACFA,AENA,ADGA,AENA,AbuCA,ADGA,AS3BA,ALeA,AGTA,AGTA;ACFA,AENA,ADGA,AENA,AbuCA,ADGA,AS3BA,ALeA,AGTA,AGTA;ACFA,AENA,ADGA,AENA,AbuCA,ADGA,AS3BA,ALeA,AGTA,AGTA;ACFA,AENA,ADGA,AENA,AbuCA,ADGA,AS3BA,ALeA,AGTA,AGTA;ACFA,AENA,ADGA,AXiCA,ADGA,AS3BA,ALeA,AGTA,AGTA;ACFA,AENA,ADGA,AXiCA,ADGA,AS3BA,ALeA,AGTA,AGTA;ACFA,AENA,ADGA,AXiCA,ADGA,AS3BA,ALeA,AGTA,AGTA;ACFA,AENA,ADGA,AXiCA,ADGA,AS3BA,ALeA,AGTA,AGTA;ACFA,AENA,ADGA,AXiCA,ADGA,AS3BA,ALeA,AGTA,AGTA;ACFA,AENA,ADGA,AXiCA,ADGA,AS3BA,ALeA,AGTA,AGTA;ACFA,AENA,ADGA,AXiCA,ADGA,AS3BA,ALeA,AGTA,AGTA;ACFA,AENA,ADGA,AXiCA,ADGA,AS3BA,ALeA,AGTA,AGTA;ACFA,AENA,ADGA,AXiCA,ADGA,AS3BA,ALeA,AGTA,AGTA;ACFA,AENA,ADGA,AXiCA,ADGA,AS3BA,ALeA,AGTA,AGTA;ACFA,AENA,ADGA,AZoCA,AS3BA,ALeA,AGTA,AGTA;ACFA,AENA,ADGA,AZoCA,AS3BA,ALeA,AGTA,AGTA;ACFA,AENA,ADGA,AZoCA,AS3BA,ALeA,AGTA,AGTA;ACFA,AENA,ADGA,AZoCA,AS3BA,ALeA,AGTA,AGTA;AGRA,ADGA,AZoCA,AS3BA,ALeA,AGTA,AGTA;AGRA,ADGA,AZoCA,AS3BA,ALeA,AGTA,AGTA;AGRA,ADGA,AZoCA,AS3BA,ALeA,AGTA,AGTA;AGRA,AbuCA,AS3BA,ALeA,AGTA,AGTA;AGRA,AbuCA,AS3BA,ALeA,AGTA;AMjBA,AbuCA,AS3BA,ALeA,AGTA;AMjBA,AbuCA,AS3BA,ALeA,AGTA;AMjBA,AbuCA,AS3BA,ALeA,AGTA;AMjBA,AbuCA,AS3BA,ALeA,AGTA;AMjBA,AbuCA,AS3BA,ALeA,AGTA;AMjBA,AbuCA,AS3BA,ALeA,AGTA;AMjBA,AbuCA,AS3BA,ALeA,AGTA;AMjBA,AbuCA,AS3BA,ALeA,AGTA;AMjBA,AbuCA,AS3BA,ALeA,AGTA;AMjBA,AbuCA,AS3BA,ALeA,AGTA;AMjBA,AbuCA,AS3BA,ALeA,AGTA;AMjBA,AbuCA,AS3BA,ALeA,AGTA;AMjBA,AbuCA,AS3BA,ALeA,AGTA;AMjBA,AbuCA,AS3BA,ALeA,AGTA;AMjBA,AbuCA,AS3BA,ALeA,AGTA;AMjBA,AbuCA,AS3BA,ALeA,AGTA;AMjBA,AbuCA,AS3BA,ALeA,AGTA;AMjBA,AbuCA,AS3BA,ALeA,AGTA;AMjBA,AbuCA,AS3BA,ALeA,AGTA;AMjBA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AS1BA,AbuCA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getAuth = exports.Auth = exports.initializeApp = exports.ErrorType = exports.Client = exports.initializeClient = void 0;\nconst auth_1 = require(\"./auth\");\nconst app_1 = require(\"./app\");\nfunction initializeClient(options) {\n    return new Client(options);\n}\nexports.initializeClient = initializeClient;\nclass Client {\n    constructor(initOptions) {\n        this.app = (0, app_1.initializeApp)(initOptions);\n        this.auth = (0, auth_1.getAuth)(this.app);\n    }\n}\nexports.Client = Client;\nvar request_1 = require(\"./app/request\");\nObject.defineProperty(exports, \"ErrorType\", { enumerable: true, get: function () { return request_1.ErrorType; } });\nvar app_2 = require(\"./app\");\nObject.defineProperty(exports, \"initializeApp\", { enumerable: true, get: function () { return app_2.initializeApp; } });\nvar auth_2 = require(\"./auth\");\nObject.defineProperty(exports, \"Auth\", { enumerable: true, get: function () { return auth_2.Auth; } });\nObject.defineProperty(exports, \"getAuth\", { enumerable: true, get: function () { return auth_2.getAuth; } });\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Auth = exports.getAuth = exports.DeviceAuthorizeState = exports.VerificationUsages = exports.ErrorType = void 0;\nconst consts_1 = require(\"./consts\");\nconst oauthclient_1 = require(\"../oauthclient\");\nconst captcha_1 = require(\"../captcha\");\nconst internal_1 = require(\"../app/internal\");\nvar consts_2 = require(\"./consts\");\nObject.defineProperty(exports, \"ErrorType\", { enumerable: true, get: function () { return consts_2.ErrorType; } });\nObject.defineProperty(exports, \"VerificationUsages\", { enumerable: true, get: function () { return consts_2.VerificationUsages; } });\nObject.defineProperty(exports, \"DeviceAuthorizeState\", { enumerable: true, get: function () { return consts_2.DeviceAuthorizeState; } });\n/**\n * Returns the existing `Auth` instance that is associated with the app\n */\nfunction getAuth(app, initOptions) {\n    return (0, internal_1._getComponent)(app, 'auth', () => {\n        const credentialsClient = (0, oauthclient_1.getOAuthClient)(app, initOptions);\n        const baseRequest = credentialsClient.request.bind(credentialsClient);\n        const captcha = (0, captcha_1.getCaptcha)(app, { request: baseRequest });\n        return new Auth({\n            credentialsClient: credentialsClient,\n            captcha: captcha,\n        });\n    });\n}\nexports.getAuth = getAuth;\n/**\n * Auth\n */\nclass Auth {\n    /**\n     * constructor\n     * @param {AuthOptions} opts\n     */\n    constructor(opts) {\n        this.request = opts.captcha.request.bind(opts.captcha);\n        this.credentialsClient = opts.credentialsClient;\n    }\n    /**\n     * Sign in.\n     * @param {SignInRequest} params A SignInRequest Object.\n     * @return {Promise<Credentials>} A Promise<Credentials> object.\n     */\n    async signIn(params) {\n        const credentials = await this.request(consts_1.ApiUrls.AUTH_SIGN_IN_URL, {\n            method: 'POST',\n            withBasicAuth: true,\n            body: params,\n        });\n        await this.credentialsClient.setCredentials(credentials);\n        return Promise.resolve(credentials);\n    }\n    /**\n     * Sign in Anonymously\n     * @return {Promise<Credentials>} A Promise<Credentials> object.\n     */\n    async signInAnonymously() {\n        const credentials = await this.request(consts_1.ApiUrls.AUTH_SIGN_IN_ANONYMOUSLY_URL, {\n            method: 'POST',\n            withBasicAuth: true,\n            body: {},\n        });\n        await this.credentialsClient.setCredentials(credentials);\n        return Promise.resolve(credentials);\n    }\n    /**\n     * Sign up.\n     * @param {SignUpRequest} params A SignUpRequest Object.\n     * @return {Promise<Credentials>} A Promise<Credentials> object.\n     */\n    async signUp(params) {\n        const data = await this.request(consts_1.ApiUrls.AUTH_SIGN_UP_URL, {\n            method: 'POST',\n            withBasicAuth: true,\n            body: params,\n        });\n        await this.credentialsClient.setCredentials(data);\n        return Promise.resolve(data);\n    }\n    /**\n     * Sign out.\n     * @param {SignoutRequest} params A SignoutRequest Object.\n     * @return {SignoutReponse} A Promise<SignoutReponse> object.\n     */\n    async signOut(params) {\n        var resp = {};\n        if (!params) {\n            params = {};\n        }\n        try {\n            resp = await this.request(consts_1.ApiUrls.AUTH_SIGNOUT_URL, {\n                method: 'POST',\n                withCredentials: true,\n                body: params,\n            });\n        }\n        catch (err) {\n            if (err.error !== oauthclient_1.ErrorType.UNAUTHENTICATED) {\n                console.log('sign_out_error', err);\n            }\n        }\n        await this.credentialsClient.setCredentials();\n        return resp;\n    }\n    /**\n     * Revoke All Devices\n     * @return {Object} A Promise<void> object.\n     */\n    async revokeAllDevices() {\n        await this.request(consts_1.ApiUrls.AUTH_REVOKE_ALL_URL, {\n            method: 'DELETE',\n            withCredentials: true,\n        });\n    }\n    /**\n     * Revoke Device\n     * @return {Object} A Promise<void> object.\n     */\n    async revokeDevice(params) {\n        await this.request(consts_1.ApiUrls.AUTHORIZED_DEVICES_DELETE_URL + params.device_id, {\n            method: 'DELETE',\n            withCredentials: true,\n        });\n    }\n    /**\n     * Send the VerificationCode.\n     * @param {SendVerificationCodeRequest} params A GetVerificationRequest Object.\n     * @return {Promise<SendVerificationCodeResponse>} A Promise<GetVerificationResponse> object.\n     */\n    async sendVerificationCode(params) {\n        let withBasicAuth = false;\n        let withCredentials = false;\n        // 发送短信时，如果时给当前用户发，则需要带上鉴权信息\n        if (params.target == 'CUR_USER') {\n            withCredentials = true;\n        }\n        else {\n            const hasLogin = await this.hasLoginState();\n            if (hasLogin) {\n                withCredentials = true;\n            }\n            else {\n                withBasicAuth = true;\n            }\n        }\n        return this.request(consts_1.ApiUrls.VERIFICATION_URL, {\n            method: 'POST',\n            withBasicAuth: withBasicAuth,\n            withCredentials: withCredentials,\n            body: params,\n            withCaptcha: true,\n        });\n    }\n    async getVerification(params) {\n        return this.sendVerificationCode(params);\n    }\n    /**\n     *  Verify the code\n     * @param {VerifyRequest} params A VerifyRequest Object.\n     * @return {Promise<VerifyResponse>} A Promise<VerifyResponse> object.\n     */\n    async verify(params) {\n        return this.request(consts_1.ApiUrls.VERIFY_URL, {\n            method: 'POST',\n            withBasicAuth: true,\n            body: params,\n        });\n    }\n    /**\n     * Reset Password\n     * @param params A ResetPasswordRequest Object\n     */\n    async resetPassword(params) {\n        return this.request(consts_1.ApiUrls.RESET_PASSWORD_URL, {\n            method: 'POST',\n            withBasicAuth: true,\n            body: params,\n        });\n    }\n    /**\n     * Gen provider redirect uri.\n     * @param {GenProviderRedirectUriRequest} params A GenProviderRedirectUriRequest object.\n     * @return {Promise<GenProviderRedirectUriResponse>} A Promise<GenProviderRedirectUriResponse> object.\n     */\n    async genProviderRedirectUri(params) {\n        const otherParams = params.other_params;\n        delete params.other_params;\n        let url = `${consts_1.ApiUrls.PROVIDER_URI_URL}?${Auth.parseParamsToSearch(params)}`;\n        if (otherParams) {\n            otherParams.forEach((value, key) => {\n                url += `&other_params[${key}]=${encodeURIComponent(value)}`;\n            });\n        }\n        return this.request(url, {\n            method: 'GET',\n            withBasicAuth: true,\n        });\n    }\n    /**\n     * Grant provider token.\n     * @param {GrantProviderTokenRequest} params A GrantProviderTokenRequest object.\n     * @return {Promise<GrantProviderTokenResponse>} A Promise<GrantProviderTokenResponse> object.\n     */\n    async grantProviderToken(params) {\n        return this.request(consts_1.ApiUrls.PROVIDER_TOKEN_URL, {\n            method: 'POST',\n            withBasicAuth: true,\n            body: params,\n        });\n    }\n    /**\n     * Grant provider token.\n     * @param {PatchProviderTokenRequest} params A PatchProviderTokenRequest object.\n     * @return {Promise<PatchProviderTokenResponse>} A Promise<PatchProviderTokenResponse> object.\n     */\n    async patchProviderToken(params) {\n        return this.request(consts_1.ApiUrls.PROVIDER_TOKEN_URL, {\n            method: 'PATCH',\n            withBasicAuth: true,\n            body: params,\n        });\n    }\n    /**\n     * Signin with provider request.\n     * @param {SignInWithProviderRequest} params A SignInWithProviderRequest object.\n     * @return {Promise<Credentials>} A Promise<Credentials> object.\n     */\n    async signInWithProvider(params) {\n        const credentials = await this.request(consts_1.ApiUrls.AUTH_SIGN_IN_WITH_PROVIDER_URL, {\n            method: 'POST',\n            withBasicAuth: true,\n            body: params,\n        });\n        await this.credentialsClient.setCredentials(credentials);\n        return Promise.resolve(credentials);\n    }\n    /**\n     * Bind with provider\n     * @param {BindWithProviderRequest} params A BindWithProviderRequest object.\n     * @return {Promise<void>} A Promise<void> object.\n     */\n    async bindWithProvider(params) {\n        return this.request(consts_1.ApiUrls.PROVIDER_BIND_URL, {\n            method: 'POST',\n            withBasicAuth: true,\n            body: params,\n            withCredentials: true,\n        });\n    }\n    /**\n     * Get the user profile.\n     * @return {Promise<UserProfile>} A Promise<UserProfile> object.\n     */\n    async getUserProfile() {\n        return this.request(consts_1.ApiUrls.USER_ME_URL, {\n            method: 'GET',\n            withCredentials: true,\n        });\n    }\n    /**\n     * Get the user profile.\n     * @return {Promise<UserProfile>} A Promise<UserProfile> object.\n     */\n    async updateUserProfile(params) {\n        return this.request(consts_1.ApiUrls.USER_ME_URL, {\n            method: 'PATCH',\n            withCredentials: true,\n            body: params,\n        });\n    }\n    /**\n     * hasLoginState check if has login state\n     * @return {Promise<boolean>} A Promise<boolean> object.\n     */\n    async hasLoginState() {\n        try {\n            await this.credentialsClient.getAccessToken();\n            return true;\n        }\n        catch (err) {\n            if (err.error === oauthclient_1.ErrorType.UNAUTHENTICATED) {\n                return false;\n            }\n            return Promise.reject(err);\n        }\n    }\n    /**\n     * loginScope return scope of current token\n     * @return {Promise<string>} A Promise<string> object.\n     */\n    async loginScope() {\n        return this.credentialsClient.getScope();\n    }\n    /**\n     * Trans by provider.\n     * @param {TransByProviderRequest} params A TransByProviderRequest object.\n     * @return {Promise<Credentials>} A Promise<Credentials> object.\n     */\n    async transByProvider(params) {\n        return this.request(consts_1.ApiUrls.USER_TRANS_BY_PROVIDER_URL, {\n            method: 'PATCH',\n            body: params,\n            withCredentials: true,\n        });\n    }\n    /**\n     * Grant token.\n     * @param {GrantTokenRequest} params A GrantTokenRequest object.\n     * @return {Promise<Credentials>} A Promise<Credentials> object.\n     */\n    async grantToken(params) {\n        const credentials = await this.request(consts_1.ApiUrls.AUTH_TOKEN_URL, {\n            method: 'POST',\n            withBasicAuth: true,\n            body: params,\n        });\n        await this.credentialsClient.setCredentials(credentials);\n        return Promise.resolve(credentials);\n    }\n    /**\n     * Get the provide list.\n     * @return {Promise<ProvidersResponse>} A Promise<UserProfileProviderList> object.\n     */\n    async getProviders() {\n        return this.request(consts_1.ApiUrls.PROVIDER_LIST_URL, {\n            method: 'GET',\n            withCredentials: true,\n        });\n    }\n    /**\n     * check if username is exist\n     * @param params CheckIfUserExistRequest\n     */\n    async checkIfUserExist(params) {\n        const url = `${consts_1.ApiUrls.USER_ME_URL}?${Auth.parseParamsToSearch(params)}`;\n        return this.request(url, {\n            method: 'GET',\n        });\n    }\n    /**\n     * unbind provider.\n     * @param {UnbindProviderRequest} params\n     * @return {Promise<void>}\n     */\n    async unbindProvider(params) {\n        return this.request(`${consts_1.ApiUrls.PROVIDER_UNBIND_URL}/${params.provider_id}`, {\n            method: 'DELETE',\n            withCredentials: true,\n        });\n    }\n    /**\n     * check Password.\n     * @param {CheckPasswordRequest} params\n     * @return {Promise<void>}\n     */\n    async checkPassword(params) {\n        return this.request(`${consts_1.ApiUrls.SUDO_URL}`, {\n            method: 'POST',\n            withCredentials: true,\n            body: params,\n        });\n    }\n    /**\n     * Edit Contact 修改 手机号 或 邮箱\n     * @param {EditContactRequest} params\n     * @return {Promise<void>}\n     */\n    async editContact(params) {\n        return this.request(`${consts_1.ApiUrls.EDIT_CONTACT_URL}`, {\n            method: 'PATCH',\n            withCredentials: true,\n            body: params,\n        });\n    }\n    /**\n     * Set Password.\n     * @param {SetPasswordRequest} params\n     * @return {Promise<void>}\n     */\n    async setPassword(params) {\n        return this.request(`${consts_1.ApiUrls.AUTH_SET_PASSWORD_URL}`, {\n            method: 'PATCH',\n            withCredentials: true,\n            body: params,\n        });\n    }\n    /**\n     * updatePasswordByOld 使用旧密码修改密码，如果已经绑定手机号，请先：sudo，再修改密码\n     * @param {UpdatePasswordRequest} params\n     * @return {Promise<void>}\n     */\n    async updatePasswordByOld(params) {\n        const sudoToken = await this.sudo({ password: params.old_password });\n        return this.setPassword({\n            sudo_token: sudoToken.sudo_token,\n            new_password: params.new_password,\n        });\n    }\n    /**\n     * sudo\n     * @param {sudo} params\n     * @return {Promise<SudoResponse>}\n     */\n    async sudo(params) {\n        return this.request(`${consts_1.ApiUrls.SUDO_URL}`, {\n            method: 'POST',\n            withCredentials: true,\n            body: params,\n        });\n    }\n    /**\n     * Get the current user verification.\n     * @param {SendVerificationCodeRequest} params A SendVerificationCodeToCurrentUser Object.\n     * @return {Promise<SendVerificationCodeResponse>} A Promise<SendVerificationCodeResponse> object.\n     */\n    async SendVerificationCodeToCurrentUser(params) {\n        params.target = 'CUR_USER';\n        return this.request(consts_1.ApiUrls.VERIFICATION_URL, {\n            method: 'POST',\n            body: params,\n            withCredentials: true,\n            withCaptcha: true,\n        });\n    }\n    /**\n     * change Bound provider.\n     * @param {ChangeBoundProviderRequest} params A GetVerificationRequest Object.\n     * @return {Promise<ChangeBoundProviderResponse>} A Promise<GetVerificationResponse> object.\n     */\n    async changeBoundProvider(params) {\n        return this.request(`${consts_1.ApiUrls.PROVIDER_LIST_URL}/${params.provider_id}/trans`, {\n            method: 'POST',\n            body: {\n                provider_trans_token: params.trans_token,\n            },\n            withCredentials: true,\n        });\n    }\n    /**\n     * set the user profile.\n     * @param {UserProfile} params A UserProfile Object.\n     * @return {Promise<UserProfile>} A Promise<UserProfile> object.\n     */\n    async setUserProfile(params) {\n        return this.request(consts_1.ApiUrls.USER_PROFILE_URL, {\n            method: 'PATCH',\n            body: params,\n            withCredentials: true,\n        });\n    }\n    /**\n     * Delete me\n     * @param params\n     */\n    async deleteMe(params) {\n        const url = `${consts_1.ApiUrls.USER_ME_URL}?${Auth.parseParamsToSearch(params)}`;\n        return this.request(url, {\n            method: 'DELETE',\n            withCredentials: true,\n        });\n    }\n    /**\n     * setCustomSignFunc set the get ticket function\n     * @param getTickFn\n     */\n    setCustomSignFunc(getTickFn) {\n        this._getCustomSignTicketFn = getTickFn;\n    }\n    /**\n     * SignInWithCustomTicket custom signIn\n     * @constructor\n     */\n    async SignInWithCustomTicket() {\n        const customSignTicketFn = this._getCustomSignTicketFn;\n        if (!customSignTicketFn) {\n            return Promise.reject({\n                error: 'failed_precondition',\n                error_description: 'please use setCustomSignFunc to set custom sign function',\n            });\n        }\n        const customTicket = await customSignTicketFn();\n        return this.signInWithProvider({\n            provider_id: 'custom',\n            provider_token: customTicket,\n        });\n    }\n    /**\n     * queryUserProfile query user profile\n     * @param params queryUserProfile query user profile\n     */\n    async queryUserProfile(params) {\n        const url = `${consts_1.ApiUrls.USER_QUERY_URL}?${Auth.parseParamsToSearch(params)}`;\n        return this.request(url, {\n            method: 'GET',\n            withCredentials: true,\n        });\n    }\n    /**\n     * Authorize oauth Authorize\n     * @param params\n     * @constructor\n     */\n    async authorize(params) {\n        return this.request(consts_1.ApiUrls.AUTHORIZE_URL, {\n            method: 'POST',\n            withCredentials: true,\n            body: params,\n        });\n    }\n    /**\n     * authorize device\n     * @param params\n     */\n    async authorizeDevice(params) {\n        return this.request(consts_1.ApiUrls.AUTHORIZE_DEVICE_URL, {\n            method: 'POST',\n            withCredentials: true,\n            body: params,\n        });\n    }\n    async deviceAuthorize(params) {\n        return this.request(consts_1.ApiUrls.AUTHORIZE_DEVICE_CODE_URL, {\n            method: 'POST',\n            withBasicAuth: true,\n            body: params,\n        });\n    }\n    /**\n     * OAuth get authorize info\n     * @param params\n     * @constructor\n     */\n    async authorizeInfo(params) {\n        const url = `${consts_1.ApiUrls.AUTHORIZE_INFO_URL}?${Auth.parseParamsToSearch(params)}`;\n        let withBasicAuth = true;\n        let withCredentials = false;\n        const hasLogin = await this.hasLoginState();\n        if (hasLogin) {\n            withCredentials = true;\n            withBasicAuth = false;\n        }\n        return this.request(url, {\n            method: 'GET',\n            withBasicAuth: withBasicAuth,\n            withCredentials: withCredentials,\n        });\n    }\n    /**\n     * get provider sub type\n     * @returns\n     */\n    async getProviderSubType() {\n        return this.request(consts_1.ApiUrls.GET_PROVIDER_TYPE, {\n            method: 'POST',\n            body: {\n                provider_id: 'weda',\n            },\n        });\n    }\n    async createCaptchaData(params) {\n        return this.request(consts_1.ApiUrls.CAPTCHA_DATA_URL, {\n            method: 'POST',\n            withBasicAuth: true,\n            body: params,\n        });\n    }\n    /**\n     * 验证输入验证码\n     * @param params.token 图形验证码token\n     * @param params.key 用户输入值\n     */\n    async verifyCaptchaData(params) {\n        return this.request(consts_1.ApiUrls.VERIFY_CAPTCHA_DATA_URL, {\n            method: 'POST',\n            withBasicAuth: true,\n            body: params,\n        });\n    }\n    static parseParamsToSearch(params) {\n        for (let key in params) {\n            if (!params[key]) {\n                delete params[key];\n            }\n        }\n        const searchParams = new URLSearchParams(params);\n        return searchParams.toString();\n    }\n}\nexports.Auth = Auth;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DeviceAuthorizeState = exports.ErrorType = exports.VerificationUsages = exports.ApiUrls = void 0;\nvar ApiUrls;\n(function (ApiUrls) {\n    ApiUrls[\"AUTH_SIGN_IN_URL\"] = \"/auth/v1/signin\";\n    ApiUrls[\"AUTH_SIGN_IN_ANONYMOUSLY_URL\"] = \"/auth/v1/signin/anonymously\";\n    ApiUrls[\"AUTH_SIGN_IN_WITH_PROVIDER_URL\"] = \"/auth/v1/signin/with/provider\";\n    ApiUrls[\"AUTH_SIGN_UP_URL\"] = \"/auth/v1/signup\";\n    ApiUrls[\"AUTH_TOKEN_URL\"] = \"/auth/v1/token\";\n    ApiUrls[\"AUTH_REVOKE_URL\"] = \"/auth/v1/revoke\";\n    ApiUrls[\"AUTH_SIGNOUT_URL\"] = \"/auth/v1/user/signout\";\n    ApiUrls[\"PROVIDER_BIND_URL\"] = \"/auth/v1/user/provider/bind\";\n    ApiUrls[\"PROVIDER_TOKEN_URL\"] = \"/auth/v1/provider/token\";\n    ApiUrls[\"PROVIDER_URI_URL\"] = \"/auth/v1/provider/uri\";\n    ApiUrls[\"USER_ME_URL\"] = \"/auth/v1/user/me\";\n    ApiUrls[\"RESET_PASSWORD_URL\"] = \"/auth/v1/reset\";\n    ApiUrls[\"USER_QUERY_URL\"] = \"/auth/v1/user/query\";\n    ApiUrls[\"USER_PROFILE_URL\"] = \"/auth/v1/user/profile\";\n    ApiUrls[\"USER_TRANS_BY_PROVIDER_URL\"] = \"/auth/v1/user/trans/by/provider\";\n    ApiUrls[\"VERIFICATION_URL\"] = \"/auth/v1/verification\";\n    ApiUrls[\"VERIFY_URL\"] = \"/auth/v1/verification/verify\";\n    ApiUrls[\"CAPTCHA_DATA_URL\"] = \"/auth/v1/captcha/data\";\n    ApiUrls[\"VERIFY_CAPTCHA_DATA_URL\"] = \"/auth/v1/captcha/data/verify\";\n    ApiUrls[\"GET_CAPTCHA_URL\"] = \"/auth/v1/captcha/init\";\n    ApiUrls[\"PROVIDER_LIST_URL\"] = \"/auth/v1/user/provider\";\n    ApiUrls[\"PROVIDER_UNBIND_URL\"] = \"/auth/v1/user/provider\";\n    ApiUrls[\"SUDO_URL\"] = \"/auth/v1/user/sudo\";\n    ApiUrls[\"EDIT_CONTACT_URL\"] = \"/auth/v1/user/contact\";\n    ApiUrls[\"AUTH_SET_PASSWORD_URL\"] = \"/auth/v1/user/password\";\n    ApiUrls[\"CHECK_IF_USER_EXIST_URL\"] = \"/auth/v1/checkIfUserExist\";\n    ApiUrls[\"AUTHORIZE_URL\"] = \"/auth/v1/user/authorize\";\n    ApiUrls[\"AUTHORIZE_DEVICE_URL\"] = \"/auth/v1/user/device/authorize\";\n    ApiUrls[\"AUTHORIZE_DEVICE_CODE_URL\"] = \"/auth/v1/device/code\";\n    ApiUrls[\"AUTHORIZE_INFO_URL\"] = \"/auth/v1/user/authorize/info\";\n    ApiUrls[\"AUTHORIZED_URL\"] = \"/auth/v1/user/authorized\";\n    ApiUrls[\"AUTHORIZED_DELETE_URL\"] = \"/auth/v1/user/authorized/\";\n    ApiUrls[\"AUTHORIZED_DEVICES_URL\"] = \"/auth/v1/user/authorized/devices\";\n    ApiUrls[\"AUTHORIZED_DEVICES_DELETE_URL\"] = \"/auth/v1/user/authorized/devices/\";\n    ApiUrls[\"AUTH_REVOKE_ALL_URL\"] = \"/auth/v1/user/revoke/all\";\n    ApiUrls[\"GET_PROVIDER_TYPE\"] = \"/auth/v1/mgr/provider/providerSubType\";\n})(ApiUrls = exports.ApiUrls || (exports.ApiUrls = {}));\nvar VerificationUsages;\n(function (VerificationUsages) {\n    VerificationUsages[\"REGISTER\"] = \"REGISTER\";\n    VerificationUsages[\"SIGN_IN\"] = \"SIGN_IN\";\n    VerificationUsages[\"PASSWORD_RESET\"] = \"PASSWORD_RESET\";\n    VerificationUsages[\"EMAIL_ADDRESS_CHANGE\"] = \"EMAIL_ADDRESS_CHANGE\";\n    VerificationUsages[\"PHONE_NUMBER_CHANGE\"] = \"PHONE_NUMBER_CHANGE\";\n})(VerificationUsages = exports.VerificationUsages || (exports.VerificationUsages = {}));\nvar ErrorType;\n(function (ErrorType) {\n    ErrorType[\"INVALID_ARGUMENT\"] = \"invalid_argument\";\n    ErrorType[\"DEADLINE_EXCEEDED\"] = \"deadline_exceeded\";\n    ErrorType[\"NOT_FOUND\"] = \"not_found\";\n    ErrorType[\"ALREADY_EXISTS\"] = \"already_exists\";\n    ErrorType[\"PERMISSION_DENIED\"] = \"permission_denied\";\n    ErrorType[\"ABORTED\"] = \"aborted\";\n    ErrorType[\"OUT_OF_RANGE\"] = \"out_of_range\";\n    ErrorType[\"UNIMPLEMENTED\"] = \"unimplemented\";\n    ErrorType[\"INTERNAL\"] = \"internal\";\n    ErrorType[\"UNAVAILABLE\"] = \"unavailable\";\n    ErrorType[\"DATA_LOSS\"] = \"data_loss\";\n    // CommonError\n    ErrorType[\"CAPTCHA_REQUIRED\"] = \"captcha_required\";\n    ErrorType[\"CAPTCHA_INVALID\"] = \"captcha_invalid\";\n    ErrorType[\"INVALID_PASSWORD\"] = \"invalid_password\";\n    ErrorType[\"PASSWORD_NOT_SET\"] = \"password_not_set\";\n    ErrorType[\"INVALID_STATUS\"] = \"invalid_status\";\n    ErrorType[\"USER_PENDING\"] = \"user_pending\";\n    ErrorType[\"USER_BLOCKED\"] = \"user_blocked\";\n})(ErrorType = exports.ErrorType || (exports.ErrorType = {}));\nvar DeviceAuthorizeState;\n(function (DeviceAuthorizeState) {\n    // 完成\n    DeviceAuthorizeState[\"ACCOMPLISHED\"] = \"ACCOMPLISHED\";\n    // 等待连接\n    DeviceAuthorizeState[\"WAITING_CONNECT\"] = \"WAITING_CONNECT\";\n    // 等待用户点击同意界面\n    DeviceAuthorizeState[\"WAITING_CONSENT\"] = \"WAITING_CONSENT\";\n    // 用户拒绝授权\n    DeviceAuthorizeState[\"ACCESS_DENIED\"] = \"ACCESS_DENIED\";\n})(DeviceAuthorizeState = exports.DeviceAuthorizeState || (exports.DeviceAuthorizeState = {}));\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getOAuthClient = exports.ErrorType = void 0;\nconst internal_1 = require(\"../app/internal\");\nconst oauthclient_1 = require(\"./oauthclient\");\nvar consts_1 = require(\"./consts\");\nObject.defineProperty(exports, \"ErrorType\", { enumerable: true, get: function () { return consts_1.ErrorType; } });\nfunction getOAuthClient(app, opts) {\n    return (0, internal_1._getComponent)(app, \"oauthclient\", () => {\n        const appOpts = app.options;\n        const oauthOpts = {\n            clientId: appOpts.clientId,\n            clientSecret: appOpts.clientSecret,\n            request: appOpts.request,\n            storage: appOpts.storage,\n        };\n        return (new oauthclient_1.OAuth2Client(oauthOpts));\n    });\n}\nexports.getOAuthClient = getOAuthClient;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports._getComponent = void 0;\n/**\n *\n * @param app - App instance\n * @param name - service name\n * @param creator - new T\n *\n * @returns the provider for the service with the matching name\n *\n * @internal\n */\nfunction _getComponent(app, name, creator) {\n    const container = app.container;\n    let component = container.get(name);\n    if (component) {\n        return component;\n    }\n    component = creator();\n    container.set(name, component);\n    return component;\n}\nexports._getComponent = _getComponent;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OAuth2Client = exports.LocalCredentials = exports.generateRequestId = exports.toResponseError = void 0;\nconst consts_1 = require(\"./consts\");\nconst uuid_1 = require(\"../utils/uuid\");\nconst base64_1 = require(\"../utils/base64\");\nconst promise_1 = require(\"../utils/promise\");\nconst RequestIdHeaderName = 'x-request-id';\nconst DeviceIdHeaderName = 'x-device-id';\nconst DeviceIdSectionName = 'device_';\nconst toResponseError = (error, options) => {\n    let responseError;\n    const formatOptions = options || {};\n    if (error instanceof Error) {\n        responseError = {\n            error: formatOptions.error || consts_1.ErrorType.LOCAL,\n            error_description: formatOptions.error_description || error.message,\n            error_uri: formatOptions.error_uri,\n            details: formatOptions.details || error.stack,\n        };\n    }\n    else {\n        const formatError = error || {};\n        responseError = {\n            error: formatOptions.error || formatError.error || consts_1.ErrorType.LOCAL,\n            error_description: formatOptions.error_description || formatError.error_description,\n            error_uri: formatOptions.error_uri || formatError.error_uri,\n            details: formatOptions.details || formatError.details,\n        };\n    }\n    return responseError;\n};\nexports.toResponseError = toResponseError;\n/**\n * Generate request id.\n * @return {string}\n */\nfunction generateRequestId() {\n    return (0, uuid_1.uuidv4)();\n}\nexports.generateRequestId = generateRequestId;\n/**\n * Check if credentials is expired.\n * @param {Credentials} credentials\n * @return {boolean}\n */\nfunction isCredentialsExpired(credentials) {\n    let isExpired = true;\n    if (credentials && credentials.expires_at && credentials.access_token) {\n        isExpired = credentials.expires_at < new Date();\n    }\n    return isExpired;\n}\n/**\n * Local credentials.\n * Local credentials, with memory cache and storage cache.\n * If the memory cache expires, the storage cache is automatically loaded.\n */\nclass LocalCredentials {\n    /**\n     * constructor\n     * @param {LocalCredentialsOptions} options\n     */\n    constructor(options) {\n        this._credentials = null;\n        this._promiseOnce = new promise_1.PromiseOnce();\n        this._tokenSectionName = options.tokenSectionName;\n        this._storage = options.storage;\n    }\n    /**\n     * setCredentials Provides an alternative fetch api request implementation with auth credentials\n     * @param {Credentials} credentials\n     */\n    async setCredentials(credentials) {\n        if (credentials && credentials.expires_in) {\n            credentials.expires_at = new Date(Date.now() + (credentials.expires_in - 30) * 1000);\n            if (this._storage) {\n                const tokenStr = JSON.stringify(credentials);\n                await this._storage.setItem(this._tokenSectionName, tokenStr);\n            }\n            this._credentials = credentials;\n        }\n        else {\n            if (this._storage) {\n                await this._storage.removeItem(this._tokenSectionName);\n            }\n            this._credentials = null;\n        }\n    }\n    /**\n     * Get credentials.\n     * @return {Promise<Credentials>}\n     */\n    async getCredentials() {\n        return this._promiseOnce.run('getCredentials', async () => {\n            if (isCredentialsExpired(this._credentials)) {\n                this._credentials = await this._getStorageCredentials();\n            }\n            return this._credentials;\n        });\n    }\n    /**\n     * Get storage credentials.\n     */\n    async _getStorageCredentials() {\n        return this._promiseOnce.run('_getStorageCredentials', async () => {\n            let credentials = null;\n            const tokenStr = await this._storage.getItem(this._tokenSectionName);\n            if (tokenStr !== undefined && tokenStr !== null) {\n                try {\n                    credentials = JSON.parse(tokenStr);\n                    if (credentials && credentials.expires_at) {\n                        credentials.expires_at = new Date(credentials.expires_at);\n                    }\n                }\n                catch (error) {\n                    await this._storage.removeItem(this._tokenSectionName);\n                    credentials = null;\n                }\n            }\n            return credentials;\n        });\n    }\n}\nexports.LocalCredentials = LocalCredentials;\n/**\n * OAuth2Client\n */\nclass OAuth2Client {\n    /**\n     * constructor\n     * @param {OAuth2ClientOptions} options\n     */\n    constructor(options) {\n        this._promiseOnce = new promise_1.PromiseOnce();\n        this._retry = this._formatRetry(options.retry, OAuth2Client._defaultRetry);\n        this._baseRequest = options.request;\n        if (!options.clientSecret) {\n            options.clientSecret = \"\";\n        }\n        if (options.clientId !== '') {\n            this._basicAuth = \"Basic \" + (0, base64_1.weBtoa)(options.clientId + \":\" + options.clientSecret);\n        }\n        this._tokenInURL = options.tokenInURL;\n        this._headers = options.headers;\n        // @ts-ignore\n        this._storage = options.storage || defaultStorage;\n        this._localCredentials = new LocalCredentials({\n            tokenSectionName: 'credentials_',\n            storage: this._storage,\n        });\n        this._refreshTokenFunc =\n            options.refreshTokenFunc || this._defaultRefreshTokenFunc;\n    }\n    /**\n     * setCredentials Provides an alternative fetch api request implementation with auth credentials\n     * @param {Credentials} credentials\n     * @return {Promise<void>}\n     */\n    setCredentials(credentials) {\n        return this._localCredentials.setCredentials(credentials);\n    }\n    /**\n     * getAccessToken return a validate access token\n     */\n    async getAccessToken() {\n        const credentials = await this._getCredentials();\n        if (credentials && credentials.access_token) {\n            return Promise.resolve(credentials.access_token);\n        }\n        return Promise.reject({ error: consts_1.ErrorType.UNAUTHENTICATED });\n    }\n    /**\n     * getScope return a validate access token\n     */\n    async getScope() {\n        let credentials = await this._localCredentials.getCredentials();\n        if (credentials == null) {\n            return this._unAuthenticatedError(\"credentials not found\");\n        }\n        return credentials.scope;\n    }\n    /**\n     * request http like simple fetch api, exp:request('/v1/user/me', {withCredentials:true})\n     * @param {string} url\n     * @param {AuthClientRequestOptions} options\n     */\n    async request(url, options) {\n        if (!options) {\n            options = {};\n        }\n        const retry = this._formatRetry(options.retry, this._retry);\n        options.headers = options.headers || {};\n        if (this._headers) {\n            options.headers = {\n                ...this._headers,\n                ...options.headers,\n            };\n        }\n        if (!options.headers[RequestIdHeaderName]) {\n            options.headers[RequestIdHeaderName] = generateRequestId();\n        }\n        if (!options.headers[DeviceIdHeaderName]) {\n            const deviceId = await this._getDeviceId();\n            options.headers[DeviceIdHeaderName] = deviceId;\n        }\n        if (options && options.withBasicAuth && this._basicAuth) {\n            options.headers['Authorization'] = this._basicAuth;\n        }\n        if (options && options.withCredentials) {\n            const credentials = await this._getCredentials();\n            if (credentials) {\n                if (this._tokenInURL) {\n                    if (url.indexOf('?') < 0) {\n                        url += '?';\n                    }\n                    url += 'access_token=' + credentials.access_token;\n                }\n                else {\n                    options.headers['Authorization'] =\n                        credentials.token_type + ' ' + credentials.access_token;\n                }\n            }\n        }\n        let response;\n        const maxRequestTimes = retry + 1;\n        for (let requestTime = 0; requestTime < maxRequestTimes; requestTime++) {\n            try {\n                response = await this._baseRequest(url, options);\n                break;\n            }\n            catch (responseError) {\n                if (options.withCredentials && responseError && responseError.error === consts_1.ErrorType.UNAUTHENTICATED) {\n                    await this.setCredentials(null);\n                    return Promise.reject(responseError);\n                }\n                if (requestTime === retry ||\n                    !responseError ||\n                    responseError.error !== 'unreachable') {\n                    return Promise.reject(responseError);\n                }\n            }\n            await this._sleep(OAuth2Client._retryInterval);\n        }\n        return response;\n    }\n    /**\n     * Check retry value.\n     * @param {number} retry\n     * @return {number}\n     */\n    _checkRetry(retry) {\n        let responseError = null;\n        if (typeof retry !== 'number' ||\n            retry < OAuth2Client._minRetry ||\n            retry > OAuth2Client._maxRetry) {\n            responseError = {\n                error: consts_1.ErrorType.UNREACHABLE,\n                error_description: 'wrong options param: retry',\n            };\n        }\n        if (responseError) {\n            throw responseError;\n        }\n        return retry;\n    }\n    /**\n     * Format retry value.\n     * @param {number} retry\n     * @param {number} defaultVale\n     * @return {number}\n     */\n    _formatRetry(retry, defaultVale) {\n        if (typeof retry === 'undefined') {\n            return defaultVale;\n        }\n        else {\n            return this._checkRetry(retry);\n        }\n    }\n    /**\n     * Sleep.\n     * @param {number} ms\n     * @return {Promise<void>}\n     */\n    async _sleep(ms) {\n        return new Promise((resolve) => {\n            setTimeout(() => {\n                resolve();\n            }, ms);\n        });\n    }\n    /**\n     * Refresh expired token.\n     * @param {Credentials} credentials\n     * @return {Promise<Credentials>}\n     */\n    async _refreshToken(credentials) {\n        return this._promiseOnce.run('_refreshToken', async () => {\n            if (!credentials || !credentials.refresh_token) {\n                return this._unAuthenticatedError('no refresh token found in credentials');\n            }\n            try {\n                const newCredentials = await this._refreshTokenFunc(credentials.refresh_token);\n                await this._localCredentials.setCredentials(newCredentials);\n                return newCredentials;\n            }\n            catch (error) {\n                if (error.error === consts_1.ErrorType.INVALID_GRANT) {\n                    await this._localCredentials.setCredentials(null);\n                    return this._unAuthenticatedError(error.error_description);\n                }\n                return Promise.reject(error);\n            }\n        });\n    }\n    /**\n     * anonymous signIn\n     * @param {Credentials} credentials\n     * @return {Promise<Credentials>}\n     */\n    async _anonymousSignIn(credentials) {\n        return this._promiseOnce.run('_anonymous', async () => {\n            if (!credentials || credentials.scope !== 'anonymous') {\n                return this._unAuthenticatedError('no anonymous in credentials');\n            }\n            try {\n                const newCredentials = await this.request('/auth/v1/signin/anonymously', {\n                    method: 'POST',\n                    withBasicAuth: true,\n                    body: {}\n                });\n                await this._localCredentials.setCredentials(newCredentials);\n                return newCredentials;\n            }\n            catch (error) {\n                if (error.error === consts_1.ErrorType.INVALID_GRANT) {\n                    await this._localCredentials.setCredentials(null);\n                    return this._unAuthenticatedError(error.error_description);\n                }\n                return Promise.reject(error);\n            }\n        });\n    }\n    /**\n     * Default refresh token function.\n     * @param {string} refreshToken\n     * @return {Promise<Credentials>}\n     */\n    _defaultRefreshTokenFunc(refreshToken) {\n        if (refreshToken === undefined || refreshToken === '') {\n            return this._unAuthenticatedError('refresh token not found');\n        }\n        return this.request('/auth/v1/token', {\n            method: 'POST',\n            withBasicAuth: true,\n            body: {\n                grant_type: 'refresh_token',\n                refresh_token: refreshToken,\n            },\n        });\n    }\n    /**\n     * Get credentials.\n     */\n    async _getCredentials() {\n        let credentials = await this._localCredentials.getCredentials();\n        if (credentials == null) {\n            return this._unAuthenticatedError(\"credentials not found\");\n        }\n        if (isCredentialsExpired(credentials)) {\n            if (credentials && credentials.scope === 'anonymous') {\n                credentials = await this._anonymousSignIn(credentials);\n            }\n            else {\n                credentials = await this._refreshToken(credentials);\n            }\n        }\n        return credentials;\n    }\n    /**\n     * Get deviceId\n     */\n    async _getDeviceId() {\n        if (this._deviceID) {\n            return this._deviceID;\n        }\n        let deviceId = await this._storage.getItem(DeviceIdSectionName);\n        if (!(typeof deviceId === 'string' &&\n            deviceId.length >= 16 &&\n            deviceId.length <= 48)) {\n            deviceId = (0, uuid_1.uuidv4)();\n            await this._storage.setItem(DeviceIdSectionName, deviceId);\n        }\n        this._deviceID = deviceId;\n        return deviceId;\n    }\n    /**\n     * Generate unAuthenticated error.\n     * @param {string} err\n     * @return {Promise<T>}\n     */\n    _unAuthenticatedError(err) {\n        return Promise.reject({\n            error: consts_1.ErrorType.UNAUTHENTICATED,\n            error_description: err,\n        });\n    }\n}\nOAuth2Client._defaultRetry = 2;\nOAuth2Client._minRetry = 0;\nOAuth2Client._maxRetry = 5;\nOAuth2Client._retryInterval = 1000;\nexports.OAuth2Client = OAuth2Client;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ErrorType = exports.Syntax = void 0;\nvar Syntax;\n(function (Syntax) {\n    Syntax[\"CLIENT_ID\"] = \"client_id\";\n    Syntax[\"CLIENT_SECRET\"] = \"client_secret\";\n    Syntax[\"RESPONSE_TYPE\"] = \"response_type\";\n    Syntax[\"SCOPE\"] = \"scope\";\n    Syntax[\"STATE\"] = \"state\";\n    Syntax[\"REDIRECT_URI\"] = \"redirect_uri\";\n    Syntax[\"ERROR\"] = \"error\";\n    Syntax[\"ERROR_DESCRIPTION\"] = \"error_description\";\n    Syntax[\"ERROR_URI\"] = \"error_uri\";\n    Syntax[\"GRANT_TYPE\"] = \"grant_type\";\n    Syntax[\"CODE\"] = \"code\";\n    Syntax[\"ACCESS_TOKEN\"] = \"access_token\";\n    Syntax[\"TOKEN_TYPE\"] = \"token_type\";\n    Syntax[\"EXPIRES_IN\"] = \"expires_in\";\n    Syntax[\"USERNAME\"] = \"username\";\n    Syntax[\"PASSWORD\"] = \"password\";\n    Syntax[\"REFRESH_TOKEN\"] = \"refresh_token\";\n})(Syntax = exports.Syntax || (exports.Syntax = {}));\nvar ErrorType;\n(function (ErrorType) {\n    ErrorType[\"UNREACHABLE\"] = \"unreachable\";\n    ErrorType[\"LOCAL\"] = \"local\";\n    ErrorType[\"CANCELLED\"] = \"cancelled\";\n    ErrorType[\"UNKNOWN\"] = \"unknown\";\n    ErrorType[\"INVALID_ARGUMENT\"] = \"invalid_argument\";\n    ErrorType[\"DEADLINE_EXCEEDED\"] = \"deadline_exceeded\";\n    ErrorType[\"NOT_FOUND\"] = \"not_found\";\n    ErrorType[\"ALREADY_EXISTS\"] = \"already_exists\";\n    ErrorType[\"PERMISSION_DENIED\"] = \"permission_denied\";\n    ErrorType[\"UNAUTHENTICATED\"] = \"unauthenticated\";\n    ErrorType[\"RESOURCE_EXHAUSTED\"] = \"resource_exhausted\";\n    ErrorType[\"FAILED_PRECONDITION\"] = \"failed_precondition\";\n    ErrorType[\"ABORTED\"] = \"aborted\";\n    ErrorType[\"OUT_OF_RANGE\"] = \"out_of_range\";\n    ErrorType[\"UNIMPLEMENTED\"] = \"unimplemented\";\n    ErrorType[\"INTERNAL\"] = \"internal\";\n    ErrorType[\"UNAVAILABLE\"] = \"unavailable\";\n    ErrorType[\"DATA_LOSS\"] = \"data_loss\";\n    // CommonError\n    ErrorType[\"ACCESS_DENIED\"] = \"access_denied\";\n    ErrorType[\"UNSUPPORTED_RESPONSE_TYPE\"] = \"unsupported_response_type\";\n    ErrorType[\"INVALID_SCOPE\"] = \"invalid_scope\";\n    ErrorType[\"INVALID_GRANT\"] = \"invalid_grant\";\n    ErrorType[\"SERVER_ERROR\"] = \"server_error\";\n    ErrorType[\"TEMPORARILY_UNAVAILABLE\"] = \"temporarily_unavailable\";\n    ErrorType[\"INTERACTION_REQUIRED\"] = \"interaction_required\";\n})(ErrorType = exports.ErrorType || (exports.ErrorType = {}));\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.uuidv4 = void 0;\n/**\n * Generate uuidv4 string.\n * @return {string}\n */\nfunction uuidv4() {\n    return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n        const r = (Math.random() * 16) | 0;\n        const v = c == 'x' ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n    });\n}\nexports.uuidv4 = uuidv4;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.weappJwtDecode = exports.base64_url_decode = exports.weAtob = exports.weBtoa = void 0;\n// weapp jwt-decode\nconst b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\nconst b64re = /^(?:[A-Za-z\\d+\\/]{4})*?(?:[A-Za-z\\d+\\/]{2}(?:==)?|[A-Za-z\\d+\\/]{3}=?)?$/;\n// btoa\nfunction weBtoa(string) {\n    string = String(string);\n    var bitmap, a, b, c, result = \"\", i = 0, rest = string.length % 3;\n    for (; i < string.length;) {\n        if ((a = string.charCodeAt(i++)) > 255 ||\n            (b = string.charCodeAt(i++)) > 255 ||\n            (c = string.charCodeAt(i++)) > 255)\n            throw new TypeError(\"Failed to execute 'btoa' on 'Window': The string to be encoded contains characters outside of the Latin1 range.\");\n        bitmap = (a << 16) | (b << 8) | c;\n        result +=\n            b64.charAt((bitmap >> 18) & 63) +\n                b64.charAt((bitmap >> 12) & 63) +\n                b64.charAt((bitmap >> 6) & 63) +\n                b64.charAt(bitmap & 63);\n    }\n    return rest ? result.slice(0, rest - 3) + \"===\".substring(rest) : result;\n}\nexports.weBtoa = weBtoa;\n// atob\nconst weAtob = function (string) {\n    string = String(string).replace(/[\\t\\n\\f\\r ]+/g, \"\");\n    if (!b64re.test(string))\n        throw new TypeError(\"Failed to execute 'atob' on 'Window': The string to be decoded is not correctly encoded.\");\n    string += \"==\".slice(2 - (string.length & 3));\n    var bitmap, result = \"\", r1, r2, i = 0;\n    for (; i < string.length;) {\n        bitmap =\n            (b64.indexOf(string.charAt(i++)) << 18) |\n                (b64.indexOf(string.charAt(i++)) << 12) |\n                ((r1 = b64.indexOf(string.charAt(i++))) << 6) |\n                (r2 = b64.indexOf(string.charAt(i++)));\n        result +=\n            r1 === 64\n                ? String.fromCharCode((bitmap >> 16) & 255)\n                : r2 === 64\n                    ? String.fromCharCode((bitmap >> 16) & 255, (bitmap >> 8) & 255)\n                    : String.fromCharCode((bitmap >> 16) & 255, (bitmap >> 8) & 255, bitmap & 255);\n    }\n    return result;\n};\nexports.weAtob = weAtob;\nfunction b64DecodeUnicode(str) {\n    return decodeURIComponent((0, exports.weAtob)(str).replace(/(.)/g, function (p) {\n        var code = p.charCodeAt(0).toString(16).toUpperCase();\n        if (code.length < 2) {\n            code = \"0\" + code;\n        }\n        return \"%\" + code;\n    }));\n}\nfunction base64_url_decode(str) {\n    var output = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    switch (output.length % 4) {\n        case 0:\n            break;\n        case 2:\n            output += \"==\";\n            break;\n        case 3:\n            output += \"=\";\n            break;\n        default:\n            throw new Error(\"Illegal base64url string!\");\n    }\n    try {\n        return b64DecodeUnicode(output);\n    }\n    catch (err) {\n        return (0, exports.weAtob)(output);\n    }\n}\nexports.base64_url_decode = base64_url_decode;\nfunction weappJwtDecode(token, options) {\n    if (typeof token !== \"string\") {\n        throw new Error(\"Invalid token specified\");\n    }\n    options = options || {};\n    var pos = options.header === true ? 0 : 1;\n    try {\n        return JSON.parse(base64_url_decode(token.split(\".\")[pos]));\n    }\n    catch (e) {\n        throw new Error(\"Invalid token specified: \" + e ? e.message : \"\");\n    }\n}\nexports.weappJwtDecode = weappJwtDecode;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PromiseOnce = void 0;\n/**\n * Promise Once\n */\nclass PromiseOnce {\n    constructor() {\n        this._fnPromiseMap = new Map();\n    }\n    /**\n     * Run Once promise.\n     * @param {string} key\n     * @param {Function} fn\n     * @return {Promise<T>}\n     */\n    async run(key, fn) {\n        let result = this._fnPromiseMap.get(key);\n        if (!result) {\n            result = new Promise(async (resolve, reject) => {\n                try {\n                    // The idle promise must be run to prevent _fnPromiseMap from\n                    // storing the current promise function.\n                    await this._runIdlePromise();\n                    const fnResult = fn();\n                    resolve(await fnResult);\n                }\n                catch (error) {\n                    reject(error);\n                }\n                finally {\n                    this._fnPromiseMap.delete(key);\n                }\n            });\n            this._fnPromiseMap.set(key, result);\n        }\n        return result;\n    }\n    /**\n     * Run idle promise.\n     * @return {Promise<void>}\n     */\n    _runIdlePromise() {\n        return Promise.resolve();\n    }\n}\nexports.PromiseOnce = PromiseOnce;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Captcha = exports.getCaptcha = void 0;\nconst consts_1 = require(\"../auth/consts\");\nconst internal_1 = require(\"../app/internal\");\nconst mp_1 = require(\"../utils/mp\");\nfunction getCaptcha(app, opts) {\n    return (0, internal_1._getComponent)(app, 'captcha', () => {\n        const initOpts = {\n            ...app.options.captchaOptions,\n            clientId: app.options.clientId,\n            request: app.options.request,\n            storage: app.options.storage,\n        };\n        if (opts && opts.request) {\n            initOpts.request = opts.request;\n        }\n        return new Captcha(initOpts);\n    });\n}\nexports.getCaptcha = getCaptcha;\nclass Captcha {\n    /**\n     * constructor\n     * @param {CaptchaOptions} opts\n     */\n    constructor(opts) {\n        this.config = opts;\n        this.tokenSectionName = `captcha_${opts.clientId || ''}`;\n    }\n    /**\n     * request http like simple fetch api, exp:request('/v1/user/me', {withCredentials:true})\n     * @param {string} url\n     * @param {AuthClientRequestOptions} options\n     */\n    async request(url, options) {\n        if (!options) {\n            options = {};\n        }\n        if (!options.method) {\n            options.method = 'GET';\n        }\n        const state = `${options.method}:${url}`;\n        let reqURL = url;\n        if (options.withCaptcha) {\n            reqURL = await this.appendCaptchaTokenToURL(url, state, false);\n        }\n        let resp;\n        try {\n            resp = await this.config.request(reqURL, options);\n        }\n        catch (err) {\n            if (err.error === consts_1.ErrorType.CAPTCHA_REQUIRED || err.error === consts_1.ErrorType.CAPTCHA_INVALID) {\n                url = await this.appendCaptchaTokenToURL(url, state, err.error === consts_1.ErrorType.CAPTCHA_INVALID);\n                return this.config.request(url, options);\n            }\n            return Promise.reject(err);\n        }\n        return resp;\n    }\n    /**\n     * getCaptchaToken 获取captchaToken\n     */\n    async getCaptchaToken(forceNewToken, state) {\n        if (!forceNewToken) {\n            // 如果本地存在，则直接返回\n            const captchaToken = await this.findCaptchaToken();\n            if (captchaToken) {\n                return captchaToken;\n            }\n        }\n        let captchaTokenResp;\n        if ((0, mp_1.isMp)() || (0, mp_1.isInMpWebView)()) {\n            /**\n             * https://iwiki.woa.com/p/4010699417\n             */\n            const captchaDataResp = await this.config.request(consts_1.ApiUrls.CAPTCHA_DATA_URL, {\n                method: 'POST',\n                body: {\n                    state,\n                    redirect_uri: '',\n                },\n                withBasicAuth: true,\n                withCredentials: false,\n            });\n            captchaTokenResp = {\n                url: `${captchaDataResp.data}?state=${encodeURIComponent(state)}&token=${captchaDataResp.token}`,\n            };\n        }\n        else {\n            const redirect_uri = `${window.location.origin + window.location.pathname}?__captcha=on`;\n            captchaTokenResp = await this.config.request(consts_1.ApiUrls.GET_CAPTCHA_URL, {\n                method: 'POST',\n                body: {\n                    client_id: this.config.clientId,\n                    redirect_uri,\n                    state,\n                },\n                withBasicAuth: true,\n            });\n        }\n        const captchaToken = captchaTokenResp.captcha_token\n            ? {\n                captcha_token: captchaTokenResp.captcha_token,\n                expires_in: captchaTokenResp.expires_in,\n            }\n            : await this.config.openURIWithCallback(captchaTokenResp.url, {\n                width: '355px',\n                height: '355px',\n            });\n        await this.saveCaptchaToken({\n            captcha_token: captchaToken.captcha_token,\n            expires_in: Number(captchaToken.expires_in),\n        });\n        return captchaToken.captcha_token;\n    }\n    async appendCaptchaTokenToURL(url, state, forceNewToken) {\n        const captchaToken = await this.getCaptchaToken(forceNewToken, state);\n        if (url.indexOf('?') > 0) {\n            url += `&captcha_token=${captchaToken}`;\n        }\n        else {\n            url += `?captcha_token=${captchaToken}`;\n        }\n        return url;\n    }\n    async saveCaptchaToken(token) {\n        token.expires_at = new Date(Date.now() + (token.expires_in - 10) * 1000);\n        const tokenStr = JSON.stringify(token);\n        await this.config.storage.setItem(this.tokenSectionName, tokenStr);\n    }\n    async findCaptchaToken() {\n        const tokenStr = await this.config.storage.getItem(this.tokenSectionName);\n        if (tokenStr !== undefined && tokenStr !== null) {\n            try {\n                const captchaToken = JSON.parse(tokenStr);\n                if (captchaToken && captchaToken.expires_at) {\n                    captchaToken.expires_at = new Date(captchaToken.expires_at);\n                }\n                const isExpired = captchaToken.expires_at < new Date();\n                if (isExpired) {\n                    return null;\n                }\n                return captchaToken.captcha_token;\n            }\n            catch (error) {\n                await this.config.storage.removeItem(this.tokenSectionName);\n                return null;\n            }\n        }\n        return null;\n    }\n}\nexports.Captcha = Captcha;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isInMpWebView = exports.isMp = void 0;\nfunction isMp() {\n    const wx = globalThis.wx;\n    if (typeof wx === 'undefined') {\n        return false;\n    }\n    if (globalThis.Page === undefined) {\n        return false;\n    }\n    if (!wx.getSystemInfoSync) {\n        return false;\n    }\n    if (!wx.getStorageSync) {\n        return false;\n    }\n    if (!wx.setStorageSync) {\n        return false;\n    }\n    if (!wx.connectSocket) {\n        return false;\n    }\n    if (!wx.request) {\n        return false;\n    }\n    try {\n        if (!wx.getSystemInfoSync()) {\n            return false;\n        }\n        if (wx.getSystemInfoSync().AppPlatform === 'qq') {\n            return false;\n        }\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}\nexports.isMp = isMp;\nlet IS_IN_MP_WEBVIEW = false;\nfunction ready() {\n    IS_IN_MP_WEBVIEW =\n        IS_IN_MP_WEBVIEW || (typeof window !== undefined && window.__wxjs_environment === 'miniprogram');\n}\ntry {\n    if (!isMp()) {\n        IS_IN_MP_WEBVIEW =\n            IS_IN_MP_WEBVIEW ||\n                !!navigator.userAgent.match(/miniprogram/i) ||\n                window.__wxjs_environment === 'miniprogram';\n        if (window && window.WeixinJSBridge && window.WeixinJSBridge.invoke) {\n            ready();\n        }\n        else if (typeof document !== 'undefined') {\n            document.addEventListener('WeixinJSBridgeReady', ready, false);\n        }\n    }\n}\ncatch (e) { }\nfunction isInMpWebView() {\n    return IS_IN_MP_WEBVIEW;\n}\nexports.isInMpWebView = isInMpWebView;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AppImpl = exports.initializeApp = void 0;\nconst request_1 = require(\"./request\");\nconst openuri_1 = require(\"./openuri\");\nconst storage_1 = require(\"./storage\");\nfunction initializeApp(options) {\n    return new AppImpl(options);\n}\nexports.initializeApp = initializeApp;\nclass AppImpl {\n    constructor(options) {\n        this._container = new Map();\n        if (!options.region) {\n            options.region = 'ap-shanghai';\n        }\n        if (!options.apiOrigin) {\n            options.apiOrigin = `https://${options.env}.${options.region}.tcb-api.tencentcloudapi.com`;\n        }\n        let storageEnv = options.env;\n        if (!options.clientId) {\n            options.clientId = '';\n        }\n        else {\n            storageEnv = options.clientId;\n        }\n        if (!options.storage) {\n            options.storage = new storage_1.DefaultStorage({ env: storageEnv });\n        }\n        if (!options.captchaOptions) {\n            options.captchaOptions = {};\n        }\n        if (!options.captchaOptions.openURIWithCallback) {\n            // 兼容之前的传参方式，options.openURIWithCallback\n            options.captchaOptions.openURIWithCallback = options.openURIWithCallback || openuri_1.defaultOpenURIWithCallback;\n        }\n        let baseRequest = options.baseRequest || options.request || request_1.defaultRequest;\n        if (!baseRequest) {\n            baseRequest = request_1.defaultRequest;\n        }\n        const apiOrigin = options.apiOrigin;\n        options.request = async (url, options) => {\n            if (url.startsWith('/')) {\n                url = apiOrigin + url;\n            }\n            return baseRequest(url, options);\n        };\n        this._options = options;\n    }\n    get options() {\n        return this._options;\n    }\n    get container() {\n        return this._container;\n    }\n}\nexports.AppImpl = AppImpl;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defaultRequest = exports.ErrorType = void 0;\nvar ErrorType;\n(function (ErrorType) {\n    ErrorType[\"UNREACHABLE\"] = \"unreachable\";\n})(ErrorType = exports.ErrorType || (exports.ErrorType = {}));\nconst defaultRequest = async (url, options) => {\n    let result;\n    let responseError;\n    // Objects must be copied to prevent modification of data such as body.\n    const copyOptions = Object.assign({}, options);\n    if (!copyOptions.method) {\n        copyOptions.method = 'GET';\n    }\n    if (copyOptions.body && typeof copyOptions.body !== 'string') {\n        copyOptions.body = JSON.stringify(copyOptions.body, (key, value) => {\n            if (value) {\n                if (value instanceof Map) {\n                    return Object.fromEntries(value.entries());\n                }\n                else if (value !== '') {\n                    return value;\n                }\n            }\n        });\n    }\n    const requestId = copyOptions.headers['x-request-id'];\n    try {\n        copyOptions.credentials = 'include';\n        const responseResult = await fetch(url, copyOptions);\n        const jsonResponse = await responseResult.json();\n        if (jsonResponse.error || responseResult.status >= 400) {\n            responseError = jsonResponse;\n            responseError.error_uri = new URL(url).pathname;\n            responseError.request_id = requestId;\n        }\n        else {\n            result = jsonResponse;\n        }\n    }\n    catch (error) {\n        responseError = {\n            error: ErrorType.UNREACHABLE,\n            error_description: error.message,\n            error_uri: new URL(url).pathname,\n            request_id: requestId,\n        };\n    }\n    if (responseError) {\n        throw responseError;\n    }\n    else {\n        return result;\n    }\n};\nexports.defaultRequest = defaultRequest;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defaultOpenURIWithCallback = void 0;\nconst consts_1 = require(\"../auth/consts\");\n/**\n * default use iframe to open url can return callback\n * for example : open https://example.com/callback?rediret_uri=http://127.0.0.1:8080/\n *     the it is done, it will callback http://127.0.0.1:8080/?data1=x&data2=3\n *\n * for example : open https://example.com/callback?rediret_uri=http://127.0.0.1:8080/?__iframe==on\n *      window.addEventListener('message', function(e) {\n        console.log(e)\n        alert('data from domain2 ---> ' + e.data);\n    }, false);\n *\n */\nconst defaultOpenURIWithCallback = (url, opts) => {\n    let iframeTag = '__iframe';\n    const { width = '355px', height = '355px' } = opts || {};\n    const matched = url.match(/^(data:.*)$/);\n    if (matched) {\n        return Promise.reject({\n            error: consts_1.ErrorType.UNIMPLEMENTED,\n            error_description: `need to impl captcha data`,\n        });\n    }\n    if (window.location.search.indexOf(iframeTag) > 0) {\n        document.body.style.display = 'none';\n    }\n    if (document.getElementById('_iframe_panel_wrap') === null) {\n        var elementDiv = document.createElement('div');\n        elementDiv.style.cssText =\n            'background-color: rgba(0, 0, 0, 0.7);position: fixed;left: 0px;right: 0px;top: 0px;bottom: 0px;padding: 9vw 0 0 0;display: none;z-index:100;';\n        elementDiv.setAttribute('id', '_iframe_panel_wrap');\n        document.body.appendChild(elementDiv);\n    }\n    const target = document.getElementById('_iframe_panel_wrap'), iframe = document.createElement('iframe');\n    target.innerHTML = '';\n    const openURL = new URL(url);\n    let search = openURL.search.substring(1);\n    let contactSign = '?';\n    if (openURL.hash.indexOf('=') > 0) {\n        search = openURL.hash.substring(1);\n        contactSign = '#';\n    }\n    const searchParams = new URLSearchParams(search);\n    const redirectUri = searchParams.get('redirect_uri');\n    if (redirectUri) {\n        const redirectUrl = new URL(redirectUri);\n        redirectUrl.searchParams.append(iframeTag, 'on');\n        searchParams.set('redirect_uri', redirectUrl.href);\n        url = openURL.origin + openURL.pathname + contactSign + searchParams.toString();\n    }\n    iframe.setAttribute('src', url);\n    iframe.setAttribute('id', '_iframe_panel_wrap_iframe');\n    iframe.style.cssText = `min-width:${width};display:block;height:${height};margin:0 auto;background-color: rgb(255, 255, 255);border: none;`;\n    target.appendChild(iframe);\n    target.style.display = 'block';\n    let callBack = new Callback();\n    // handle callback from iframe post message\n    window.addEventListener('message', (e) => {\n        if (e.origin == openURL.origin && callBack.callFunc) {\n            if (!(typeof e.data === 'string')) {\n                return;\n            }\n            target.style.display = 'none';\n            const data = JSON.parse(e.data);\n            try {\n                callBack.callFunc(data);\n            }\n            catch (e) { }\n        }\n    }, false);\n    return new Promise((resolve, reject) => {\n        callBack.callFunc = (data) => {\n            if (data.error) {\n                return reject(data);\n            }\n            return resolve(data);\n        };\n        // handle callback from iframe redirect uri\n        iframe.onload = () => {\n            try {\n                var windowLocation = window.location;\n                var iframeLocation = iframe.contentWindow.location;\n                if (iframeLocation.host + iframeLocation.pathname === windowLocation.host + windowLocation.pathname) {\n                    target.style.display = 'none';\n                    const iframeUrlParams = new URLSearchParams(iframeLocation.search);\n                    const data = {};\n                    iframeUrlParams.forEach((v, k) => {\n                        data[k] = v;\n                    });\n                    if (data.error) {\n                        return reject({\n                            error: iframeUrlParams.get('error'),\n                            error_description: iframeUrlParams.get('error_description'),\n                        });\n                    }\n                    return resolve(data);\n                }\n                else {\n                    target.style.display = 'block';\n                }\n            }\n            catch (error) {\n                target.style.display = 'block';\n            }\n        };\n    });\n};\nexports.defaultOpenURIWithCallback = defaultOpenURIWithCallback;\nclass Callback {\n}\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DefaultStorage = void 0;\n/**\n * Default Storage.\n */\nclass DefaultStorage {\n    constructor(opts) {\n        this._env = opts.env;\n    }\n    /**\n     * Get item.\n     * @param {string} key\n     */\n    async getItem(key) {\n        return localStorage.getItem(key + this._env);\n    }\n    /**\n     * Remove item.\n     * @param {string} key\n     */\n    async removeItem(key) {\n        return localStorage.removeItem(key + this._env);\n    }\n    /**\n     * Set item.\n     * @param {string} key\n     * @param {string} value\n     */\n    async setItem(key, value) {\n        return localStorage.setItem(key + this._env, value);\n    }\n}\nexports.DefaultStorage = DefaultStorage;\n"]}